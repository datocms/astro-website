---
import { Space } from '~/components/Space';
import { Tab, Tabs } from '~/components/Tabs';
import type { Filters } from './_utils';
import { gqlExample } from './_gqlExample';
import DocCallout from '~/components/docs/blocks/DocCallout/Base.astro';
import { Code } from '~/components/Code';

type Props = {
  fieldName: string;
  filters: Filters;
};

const { fieldName, filters } = Astro.props;
---

<Space top={1} bottom={1}>
  <Tabs>
    {
      Object.entries(filters).map(([filterName, filter]) => (
        <Tab title={filterName} code noPadding>
          <p>{filter.description}</p>
          <Code code={gqlExample(fieldName, filterName, filter.input)} language="graphql" />
          {filter.input.type === 'scalar' && filter.input.input_type === 'date_time' && (
            <DocCallout calloutType="neutral" title="Filtering adjacent records">
              <p>
                Truncation to the nearest minute may cause filters to return unintended records
                (e.g., <code>gt: "2025-05-06T09:36:01+02:00"</code> becomes{' '}
                <code>gt: "2025-05-06T09:36:00+02:00"</code> and unexpectedly includes records at{' '}
                <code>2025-05-06T09:36:01+02:00</code>).
              </p>
              <p>
                Add an additional filter condition (like <code>slug: {'{neq: $slug}'}</code> in the
                example below) to ensure unintended records are excluded from the results:
              </p>
              <Code
                code="query NextArticle($slug: String, $firstPublishedAt: DateTime) {\n  next: article(\n    orderBy: _firstPublishedAt_ASC\n    filter: {\n      _firstPublishedAt: {gt: $firstPublishedAt},\n      slug: {neq: $slug}\n    }\n  ) {\n    title\n    _firstPublishedAt\n  }\n}"
                language="graphql"
              />
            </DocCallout>
          )}
        </Tab>
      ))
    }
  </Tabs>
</Space>
