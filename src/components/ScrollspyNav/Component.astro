---
type Props = {
  observerRoot?: string;
  observerRootMargin?: string;
  observerThreshold?: number;
  fromStructuredText?: boolean;
};

const { observerRoot, observerRootMargin, observerThreshold, fromStructuredText } = Astro.props;
---

<scrollspy-nav
  observer-root={observerRoot}
  observer-root-margin={observerRootMargin}
  observer-threshold={observerThreshold}
  from-structured-text={fromStructuredText}
>
  <slot />
</scrollspy-nav>

<script>
  import { WebComponent } from '~/lib/WebComponent';

  customElements.define(
    'scrollspy-nav',
    class ScrollspyNav extends WebComponent {
      private activeAnchor: HTMLAnchorElement | undefined;
      private currentAnchor: HTMLElement | null = null;

      parsedCallback(): void {
        this.currentAnchor = this.querySelector('[data-current-anchor]');
        const anchors = this.$$<HTMLAnchorElement>('a');
        const sections: HTMLElement[] = [];

        anchors.forEach((anchor) => {
          if (new URL(anchor.href).host !== window.location.host) return;
          if (!anchor.hash.startsWith('#')) return;

          const el = document.querySelector(anchor.hash);
          const value = anchor.hash.substring(1);

          if (!el) {
            console.warn(
              `[${this.localName}]: Element with id "${value}" doesn't exist on this page.`,
            );
            return;
          }

          sections.push(el as HTMLElement);
        });

        const onIntersect = (entries: IntersectionObserverEntry[]): void => {
          for (const entry of entries) {
            if (!entry.isIntersecting) return;

            const adjustedEntry = fromStructuredText
              ? entry.target.querySelector('a')!
              : entry.target;

            const anchor = this.querySelector(`[href="#${adjustedEntry.id}"`) as HTMLAnchorElement;

            if (!anchor) {
              console.warn(
                `[${this.localName}]: Link with href "#${adjustedEntry.id}" doesn't exist on this page.`,
              );
              continue;
            }

            this.setActiveAnchor(anchor);
          }

          if (!this.activeAnchor) {
            this.setActiveAnchor(anchors[0]!);
          }
        };

        const root = this.getAttribute('observer-root');
        const rootMargin = this.getAttribute('observer-root-margin');
        const threshold = this.getAttribute('observer-threshold');
        const fromStructuredText = this.getAttribute('from-structured-text');

        const observer = new IntersectionObserver(onIntersect, {
          root: root ? document.querySelector(root) : null,
          rootMargin: rootMargin || fromStructuredText ? '-10% 0% -90% 0%' : '-25% 0% -75% 0%',
          threshold: threshold ? Number(threshold) : undefined,
        });

        for (const section of sections) {
          observer.observe(fromStructuredText ? section.parentElement! : section);
        }
      }

      setActiveAnchor(el: HTMLAnchorElement): void {
        this.activeAnchor?.removeAttribute('aria-current');
        el.setAttribute('aria-current', 'true');
        this.activeAnchor = el;

        if (this.currentAnchor) {
          this.currentAnchor.textContent = el.textContent;
        }
      }
    },
  );
</script>
